"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryMetrics = void 0;
const counter_1 = require("./metric/counter");
const gauge_1 = require("./metric/gauge");
const metric_1 = require("./metric/metric");
const timed_1 = require("./metric/timed");
/**
 * Metrics class that keeps results in memory, for use in Forge Runtime and
 * testing.
 */
class InMemoryMetrics extends metric_1.InMemoryMetric {
    constructor(tags, name = '') {
        super(name, tags);
        this._timers = [];
        this._counters = new Map();
        this._gauges = new Map();
        this._children = new Map();
    }
    getTimers() {
        return this._timers;
    }
    getCounters() {
        return this._counters;
    }
    getGauges() {
        return this._gauges;
    }
    getChildren() {
        return this._children;
    }
    tagsWith(tags) {
        return { ...this.getTags(), ...tags };
    }
    getHashedMetricName(name, tags) {
        const sortedTags = Object.entries(this.tagsWith(tags)).sort();
        return `${name}_${JSON.stringify(sortedTags)}`;
    }
    child(name, tags) {
        const hashedMetricName = this.getHashedMetricName(name, tags);
        if (!this._children.has(hashedMetricName)) {
            const child = new InMemoryMetrics(this.tagsWith(tags), name);
            this._children.set(hashedMetricName, child);
        }
        return this._children.get(hashedMetricName);
    }
    counter(name, tags) {
        const hashedMetricName = this.getHashedMetricName(name, tags);
        if (!this._counters.has(hashedMetricName)) {
            const counter = new counter_1.InMemoryCounterMetric(name, this.tagsWith(tags));
            this._counters.set(hashedMetricName, counter);
        }
        return this._counters.get(hashedMetricName);
    }
    counterByName(name) {
        const filteredMetrics = Array.from(this.getCounters().values()).filter(v => v.getName() === name);
        if (filteredMetrics.length !== 1) {
            throw new Error(`Expected to find a single counter with name ${name}, but found ${filteredMetrics.length}`);
        }
        return filteredMetrics[0];
    }
    gauge(name, tags) {
        const hashedMetricName = this.getHashedMetricName(name, tags);
        if (!this._gauges.has(hashedMetricName)) {
            const gauge = new gauge_1.InMemoryGaugeMetric(name, this.tagsWith(tags));
            this._gauges.set(hashedMetricName, gauge);
        }
        return this._gauges.get(hashedMetricName);
    }
    gaugeByName(name) {
        const filteredMetrics = Array.from(this.getGauges().values()).filter(v => v.getName() === name);
        if (filteredMetrics.length !== 1) {
            throw new Error(`Expected to find a single gauge with name ${name}, but found ${filteredMetrics.length}`);
        }
        return filteredMetrics[0];
    }
    timerByName(name) {
        const timer = this._timers.find(t => t.getName() === name);
        if (!timer) {
            throw new Error(`Failed to find timer with name ${name}`);
        }
        return timer;
    }
    timing(name, tags) {
        const timer = new timed_1.InMemoryTimedMetric(name, this.tagsWith(tags));
        this._timers.push(timer);
        return timer;
    }
    /* istanbul ignore next */
    event(_title, _description) {
        throw new Error('Events are not implemented.');
    }
    /* istanbul ignore next */
    set(_name, _tags) {
        throw new Error('Sets are not implemented.');
    }
    /* istanbul ignore next */
    histogram(_name, _buckets, _tags) {
        throw new Error('Histograms are not implemented.');
    }
}
exports.InMemoryMetrics = InMemoryMetrics;
//# sourceMappingURL=metrics.js.map