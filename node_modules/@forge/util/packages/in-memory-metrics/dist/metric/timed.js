"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryTimedMetric = void 0;
const metric_1 = require("./metric");
const MILLISEC_TO_NANOSEC = 1000000;
class InMemoryTimedMetric extends metric_1.InMemoryMetric {
    constructor() {
        super(...arguments);
        this.latency = 0;
        this.started = false;
        this.startedAt = BigInt(0);
    }
    getTime() {
        if (this.started) {
            this.stopTimer();
        }
        return this.format(this.latency);
    }
    format(input, opts) {
        return parseFloat(input.toFixed(opts?.precision || 2));
    }
    stopTimer(extraTags) {
        const latency = process.hrtime.bigint() - this.startedAt;
        this.started = false;
        this.set(Number(latency) / MILLISEC_TO_NANOSEC, extraTags);
    }
    measure() {
        this.startedAt = process.hrtime.bigint();
        this.started = true;
        return {
            stop: (extraTags, opts) => {
                this.stopTimer(extraTags);
                return this.format(this.latency, opts);
            },
        };
    }
    set(val, extraTags) {
        this.latency = val;
        if (extraTags) {
            this.additionalInfo = {
                ...this.additionalInfo,
                ...extraTags,
            };
        }
    }
}
exports.InMemoryTimedMetric = InMemoryTimedMetric;
//# sourceMappingURL=timed.js.map