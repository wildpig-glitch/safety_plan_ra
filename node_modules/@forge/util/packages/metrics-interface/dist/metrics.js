"use strict";
/* eslint-disable @typescript-eslint/no-namespace, import/export */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoMetrics = exports.Timing = void 0;
const node_perf_hooks_1 = require("node:perf_hooks");
const perfNow = node_perf_hooks_1.performance.now.bind(node_perf_hooks_1.performance);
var Timing;
(function (Timing) {
    Timing.measure = (cb, timingOptions) => {
        const now = timingOptions?.now || /* istanbul ignore next - relies on perf_hooks */ perfNow;
        const start = now();
        return {
            stop: (tags) => {
                const latency = now() - start;
                const result = parseFloat(latency.toFixed(timingOptions?.precision));
                cb(result, tags);
                return result;
            },
        };
    };
})(Timing || (exports.Timing = Timing = {}));
// A simple class that implements the interface without actually doing anything.
// You can use this in tests as a stub, as part of an abstract class, or where
// you need to have something that implements Metrics without its functionality.
class NoMetrics {
    child(_name) {
        return this;
    }
    counter(_name) {
        return {
            incr: () => { },
            decr: () => { },
            incrBy: (_val) => { },
            decrBy: (_val) => { },
        };
    }
    gauge(_name) {
        return {
            set: (_val) => { },
        };
    }
    set(_name) {
        return {
            add: (_val) => { },
        };
    }
    timing(_name) {
        return {
            set: (_val) => { },
            measure: () => {
                return {
                    stop: () => 0,
                };
            },
        };
    }
    histogram(_name) {
        return {
            set: (_val) => { },
            measure: () => {
                return {
                    stop: () => 0,
                };
            },
        };
    }
    event(_title, _description) { }
}
exports.NoMetrics = NoMetrics;
//# sourceMappingURL=metrics.js.map