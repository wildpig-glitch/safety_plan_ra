"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const query_api_1 = require("../query-api");
const query_api_2 = require("../entity-storage/query-api");
const conditions_1 = require("../conditions");
const conditions_2 = require("../eap/conditions");
const query_interfaces_1 = require("../query-interfaces");
describe('DefaultQueryBuilder Untyped entities', () => {
    function newGlobalStorage() {
        return {
            list: jest.fn()
        };
    }
    it('should fetch multiple values', async () => {
        const globalStorage = newGlobalStorage();
        const queryResults = [
            {
                key: 'test',
                value: {}
            }
        ];
        globalStorage.list.mockResolvedValue({
            results: queryResults,
            nextCursor: 'next'
        });
        const { results, nextCursor } = await new query_api_1.DefaultQueryBuilder(globalStorage).getMany();
        expect(results).toEqual(queryResults);
        expect(nextCursor).toEqual('next');
        expect(globalStorage.list).toHaveBeenCalledWith({});
    });
    describe('getSingle', () => {
        it.each([
            [{ key: 'test', value: {} }, [{ key: 'test', value: {} }]],
            [undefined, []]
        ])('Should return %o when getting %o from list API', async (value, listResult) => {
            const globalStorage = newGlobalStorage();
            globalStorage.list.mockResolvedValue({
                results: listResult
            });
            const result = await new query_api_1.DefaultQueryBuilder(globalStorage).getOne();
            expect(result).toEqual(value);
            expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
                limit: 1
            }));
        });
    });
    it('should allow specifying a cursor', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).cursor('cursor').getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            cursor: 'cursor'
        }));
    });
    it('should allow specifying a "starts with" condition', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).where('key', (0, conditions_1.startsWith)('test')).getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            where: [
                {
                    field: 'key',
                    condition: 'STARTS_WITH',
                    value: 'test'
                }
            ]
        }));
    });
    it('should allow specifying a "not equal to" condition', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).where('key', (0, conditions_2.isNotEqualTo)(['test', 'test2'])).getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            where: [
                {
                    field: 'key',
                    condition: 'NOT_EQUAL_TO',
                    value: ['test', 'test2']
                }
            ]
        }));
    });
    it('should allow specifying an "is in" condition', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).where('key', (0, conditions_2.isIn)(['test', 'test2'])).getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            where: [
                {
                    field: 'key',
                    condition: 'IN',
                    value: ['test', 'test2']
                }
            ]
        }));
    });
    it('should allow specifying a condition', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).where('key', (0, conditions_1.startsWith)('test')).getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            where: [
                {
                    field: 'key',
                    condition: 'STARTS_WITH',
                    value: 'test'
                }
            ]
        }));
    });
    it('should allow specifying a limit', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_1.DefaultQueryBuilder(globalStorage).limit(10).getMany();
        expect(globalStorage.list).toHaveBeenCalledWith(expect.objectContaining({
            limit: 10
        }));
    });
});
describe('DefaultQueryBuilder CustomEntities', () => {
    function newGlobalStorage() {
        return {
            listCustomEntities: jest.fn()
        };
    }
    it('should only have "entity" as option for default base query builder', () => {
        const globalStorage = newGlobalStorage();
        const baseQueryBuilderInstance = new query_api_2.CustomEntityBuilder(globalStorage);
        expect(baseQueryBuilderInstance).toHaveProperty('entity');
        expect(baseQueryBuilderInstance).not.toHaveProperty('index');
        expect(baseQueryBuilderInstance).not.toHaveProperty('where');
        expect(baseQueryBuilderInstance).not.toHaveProperty('andFilter');
        expect(baseQueryBuilderInstance).not.toHaveProperty('orFilter');
        expect(baseQueryBuilderInstance).not.toHaveProperty('cursor');
        expect(baseQueryBuilderInstance).not.toHaveProperty('limit');
        expect(baseQueryBuilderInstance).not.toHaveProperty('getOne');
        expect(baseQueryBuilderInstance).not.toHaveProperty('getMany');
        expect(baseQueryBuilderInstance).not.toHaveProperty('sort');
    });
    it('should only have "index" as option once "entity" is initialized', () => {
        const globalStorage = newGlobalStorage();
        const baseQueryBuilderInstanceWithEntity = new query_api_2.CustomEntityBuilder(globalStorage).entity('books');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('entity');
        expect(baseQueryBuilderInstanceWithEntity).toHaveProperty('index');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('where');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('andFilter');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('orFilter');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('cursor');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('limit');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('getOne');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('getMany');
        expect(baseQueryBuilderInstanceWithEntity).not.toHaveProperty('sort');
    });
    it('should have "where", "andFilter", "orFilter", "cursor", "limit", "sort", "getOne", "getMany" as options once "index" is initialized', () => {
        const globalStorage = newGlobalStorage();
        const queryBuilderInstanceWithIndex = new query_api_2.CustomEntityBuilder(globalStorage).entity('books').index('by-key');
        expect(queryBuilderInstanceWithIndex).not.toHaveProperty('entity');
        expect(queryBuilderInstanceWithIndex).not.toHaveProperty('index');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('where');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('andFilter');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('orFilter');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('cursor');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('limit');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('sort');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('getOne');
        expect(queryBuilderInstanceWithIndex).toHaveProperty('getMany');
    });
    it('should not have "orFilter" once "andFilter" is used', () => {
        const globalStorage = newGlobalStorage();
        const queryBuilderInstanceWithAndFilter = new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-key')
            .andFilter('first_name', conditions_2.FilterConditions.beginsWith('John'));
        expect(queryBuilderInstanceWithAndFilter).not.toHaveProperty('entity');
        expect(queryBuilderInstanceWithAndFilter).not.toHaveProperty('index');
        expect(queryBuilderInstanceWithAndFilter).not.toHaveProperty('orFilter');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('where');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('andFilter');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('cursor');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('limit');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('sort');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('getOne');
        expect(queryBuilderInstanceWithAndFilter).toHaveProperty('getMany');
    });
    it('should not have "andFilter" once "orFilter" is used', () => {
        const globalStorage = newGlobalStorage();
        const queryBuilderInstanceWithOrFilter = new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-key')
            .orFilter('first_name', conditions_2.FilterConditions.beginsWith('John'));
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('entity');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('index');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('andFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('where');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('orFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('cursor');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('limit');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('sort');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getOne');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getMany');
    });
    it('should be able to call "where", "cursor", "limit", "getOne", "getMany" after chaining multiple "orFilter"', async () => {
        const globalStorage = newGlobalStorage();
        const queryBuilderInstanceWithOrFilter = new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating-and-year', {
            partition: [2019, 'John']
        })
            .orFilter('author', conditions_2.FilterConditions.contains('Doyle'))
            .orFilter('genre', conditions_2.FilterConditions.equalsTo('horror'))
            .where(conditions_2.WhereConditions.beginsWith('harry'))
            .cursor('DUMMY_CURSOR_1234')
            .limit(10)
            .sort(query_interfaces_1.SortOrder.DESC);
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('entity');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('index');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('andFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('where');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('orFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('cursor');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('limit');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('sort');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getOne');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getMany');
        await queryBuilderInstanceWithOrFilter.getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            sort: query_interfaces_1.SortOrder.DESC,
            entityName: 'books',
            indexName: 'by-rating-and-year',
            partition: [2019, 'John'],
            filterOperator: 'or',
            range: {
                condition: 'BEGINS_WITH',
                values: ['harry']
            },
            filters: [
                {
                    property: 'author',
                    condition: 'CONTAINS',
                    values: ['Doyle']
                },
                {
                    property: 'genre',
                    condition: 'EQUAL_TO',
                    values: ['horror']
                }
            ],
            limit: 10,
            cursor: 'DUMMY_CURSOR_1234'
        }));
    });
    it('should be able to call "where", "cursor", "limit", "getOne", "getMany" after chaining multiple "andFilter"', async () => {
        const globalStorage = newGlobalStorage();
        const queryBuilderInstanceWithOrFilter = new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating-and-year', {
            partition: [2019, 'John']
        })
            .andFilter('author', conditions_2.FilterConditions.contains('Doyle'))
            .andFilter('genre', conditions_2.FilterConditions.equalsTo('horror'))
            .where(conditions_2.WhereConditions.beginsWith('harry'))
            .cursor('DUMMY_CURSOR_1234')
            .limit(10)
            .sort(query_interfaces_1.SortOrder.DESC);
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('entity');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('index');
        expect(queryBuilderInstanceWithOrFilter).not.toHaveProperty('orFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('where');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('andFilter');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('cursor');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('limit');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('sort');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getOne');
        expect(queryBuilderInstanceWithOrFilter).toHaveProperty('getMany');
        await queryBuilderInstanceWithOrFilter.getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            sort: query_interfaces_1.SortOrder.DESC,
            entityName: 'books',
            indexName: 'by-rating-and-year',
            partition: [2019, 'John'],
            filterOperator: 'and',
            range: {
                condition: 'BEGINS_WITH',
                values: ['harry']
            },
            filters: [
                {
                    property: 'author',
                    condition: 'CONTAINS',
                    values: ['Doyle']
                },
                {
                    property: 'genre',
                    condition: 'EQUAL_TO',
                    values: ['horror']
                }
            ],
            limit: 10,
            cursor: 'DUMMY_CURSOR_1234'
        }));
    });
    it('should pass when BETWEEN filter and range are passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.between([1, 2]))
            .andFilter('author', conditions_2.FilterConditions.between([3, 4]))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            range: {
                condition: 'BETWEEN',
                values: [1, 2]
            },
            filters: [
                {
                    property: 'author',
                    condition: 'BETWEEN',
                    values: [3, 4]
                }
            ]
        }));
    });
    it('should pass when BEGINS_WITH filter and range are passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.beginsWith(1))
            .andFilter('author', conditions_2.FilterConditions.beginsWith(2))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            range: {
                condition: 'BEGINS_WITH',
                values: [1]
            },
            filters: [
                {
                    property: 'author',
                    condition: 'BEGINS_WITH',
                    values: [2]
                }
            ]
        }));
    });
    it('should pass when EXISTS filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating')
            .andFilter('rating', conditions_2.FilterConditions.exists())
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-rating',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'EXISTS',
                    values: [true]
                }
            ]
        }));
    });
    it('should pass when DOES_NOT_EXIST filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating')
            .andFilter('rating', conditions_2.FilterConditions.doesNotExist())
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-rating',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'NOT_EXISTS',
                    values: [true]
                }
            ]
        }));
    });
    it('should pass when GREATER_THAN filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.isGreaterThan(1))
            .andFilter('rating', conditions_2.FilterConditions.isGreaterThan(1))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            range: {
                condition: 'GREATER_THAN',
                values: [1]
            },
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'GREATER_THAN',
                    values: [1]
                }
            ]
        }));
    });
    it('should pass when GREATER_THAN_EQUAL_TO filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.isGreaterThanEqualTo(1))
            .andFilter('rating', conditions_2.FilterConditions.isGreaterThanEqualTo(1))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            range: {
                condition: 'GREATER_THAN_EQUAL_TO',
                values: [1]
            },
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'GREATER_THAN_EQUAL_TO',
                    values: [1]
                }
            ]
        }));
    });
    it('should pass when LESS_THAN filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.isLessThan(1))
            .andFilter('rating', conditions_2.FilterConditions.isLessThan(1))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            range: {
                condition: 'LESS_THAN',
                values: [1]
            },
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'LESS_THAN',
                    values: [1]
                }
            ]
        }));
    });
    it('should pass when LESS_THAN_EQUAL_TO filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.isLessThanEqualTo(1))
            .andFilter('rating', conditions_2.FilterConditions.isLessThanEqualTo(1))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            range: {
                condition: 'LESS_THAN_EQUAL_TO',
                values: [1]
            },
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'LESS_THAN_EQUAL_TO',
                    values: [1]
                }
            ]
        }));
    });
    it('should pass when CONTAINS filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .andFilter('rating', conditions_2.FilterConditions.contains('Conan'))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'CONTAINS',
                    values: ['Conan']
                }
            ]
        }));
    });
    it('should pass when NOT_CONTAINS filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .andFilter('rating', conditions_2.FilterConditions.doesNotContain('Conan'))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'NOT_CONTAINS',
                    values: ['Conan']
                }
            ]
        }));
    });
    it('should pass when EQUAL_TO filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .andFilter('rating', conditions_2.FilterConditions.equalsTo('Conan'))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'EQUAL_TO',
                    values: ['Conan']
                }
            ]
        }));
    });
    it('should pass when NOT_EQUAL_TO filter is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .andFilter('rating', conditions_2.FilterConditions.notEqualsTo('Conan'))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'and',
            filters: [
                {
                    property: 'rating',
                    condition: 'NOT_EQUAL_TO',
                    values: ['Conan']
                }
            ]
        }));
    });
    it('should pass when filter operator is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-author')
            .where(conditions_2.WhereConditions.between([1, 2]))
            .orFilter('author', conditions_2.FilterConditions.between([3, 4]))
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            entityName: 'books',
            indexName: 'by-author',
            filterOperator: 'or',
            range: {
                condition: 'BETWEEN',
                values: [1, 2]
            },
            filters: [
                {
                    property: 'author',
                    condition: 'BETWEEN',
                    values: [3, 4]
                }
            ]
        }));
    });
    it('should pass when ASC sort is passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating-and-year', {
            partition: [2019]
        })
            .where(conditions_2.WhereConditions.between([1, 2]))
            .sort(query_interfaces_1.SortOrder.ASC)
            .limit(10)
            .cursor('DUMMY_CURSOR_1234')
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            sort: query_interfaces_1.SortOrder.ASC,
            entityName: 'books',
            indexName: 'by-rating-and-year',
            partition: [2019],
            range: {
                condition: 'BETWEEN',
                values: [1, 2]
            },
            limit: 10,
            cursor: 'DUMMY_CURSOR_1234'
        }));
    });
    it('should pass when All entity queries operator are passed', async () => {
        const globalStorage = newGlobalStorage();
        await new query_api_2.CustomEntityBuilder(globalStorage)
            .entity('books')
            .index('by-rating-and-year', {
            partition: [2019, 'John']
        })
            .where(conditions_2.WhereConditions.between([1, 2]))
            .sort(query_interfaces_1.SortOrder.DESC)
            .orFilter('author', conditions_2.FilterConditions.contains('Doyle'))
            .limit(10)
            .cursor('DUMMY_CURSOR_1234')
            .getMany();
        expect(globalStorage.listCustomEntities).toHaveBeenCalledWith(expect.objectContaining({
            sort: query_interfaces_1.SortOrder.DESC,
            entityName: 'books',
            indexName: 'by-rating-and-year',
            partition: [2019, 'John'],
            filterOperator: 'or',
            range: {
                condition: 'BETWEEN',
                values: [1, 2]
            },
            filters: [
                {
                    property: 'author',
                    condition: 'CONTAINS',
                    values: ['Doyle']
                }
            ],
            limit: 10,
            cursor: 'DUMMY_CURSOR_1234'
        }));
    });
});
